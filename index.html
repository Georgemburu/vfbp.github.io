<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>📊 Deriv Live Trades Dashboard</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      background: #121212; /* Darker background */
      color: #e0e0e0; /* Lighter text */
      padding: 20px;
      margin: 0;
      line-height: 1.6;
    }
    .container {
      max-width: 900px;
      margin: auto;
      background: #1e1e1e; /* Card background */
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .main-header-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid #333;
        padding-bottom: 10px;
        margin-bottom: 20px; /* Replaces h2's margin-bottom */
    }
    .main-header-container h2 {
        color: #bb86fc; /* Accent color for headers */
        /* Removed border-bottom and padding-bottom as it's on parent */
        margin-top: 0;
        margin-bottom: 0; /* Align with button */
    }
    h3 {
      color: #bb86fc; /* Accent color for headers */
      border-bottom: 1px solid #333;
      padding-bottom: 10px;
      margin-top: 0;
    }
    label {
      display: block;
      margin-top: 10px;
      margin-bottom: 5px;
      color: #a0a0a0; /* Lighter label color */
      font-weight: 500;
    }
    input[type="text"], input[type="number"], select, textarea {
      width: calc(100% - 24px); /* Full width minus padding and border */
      padding: 12px;
      margin-bottom: 12px; /* Consistent margin */
      border-radius: 5px;
      border: 1px solid #444; /* Subtle border */
      background: #2c2c2c; /* Input background */
      color: #e0e0e0;
      font-size: 14px;
      box-sizing: border-box;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    textarea {
        min-height: 100px;
        resize: vertical;
    }
    input[type="text"]:focus, input[type="number"]:focus, select:focus, textarea:focus {
        border-color: #bb86fc;
        box-shadow: 0 0 0 2px rgba(187, 134, 252, 0.3);
        outline: none;
    }
    button {
      background: #03dac6; /* Primary action color */
      color: #121212; /* Dark text on light button */
      padding: 12px 20px;
      margin: 10px 5px 10px 0;
      border-radius: 5px;
      border: none;
      font-size: 15px;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
    }
    button:hover {
      background: #01ab9d; /* Slightly darker shade on hover */
      transform: translateY(-1px);
    }
    button:active {
        transform: translateY(0px);
    }
    button:disabled {
      background: #444;
      color: #888;
      cursor: not-allowed;
      transform: none;
    }
    .secondary-action-button {
        background: #3a3a3a; /* Darker, less prominent background */
        color: #03dac6; /* Accent color text */
        border: 1px solid #03dac6; /* Accent color border */
        padding: 8px 15px; /* Slightly smaller padding */
        font-size: 13px;
        font-weight: normal;
    }
    .secondary-action-button:hover {
        background: #4a4a4a;
        border-color: #01ab9d;
        color: #01ab9d;
    }
    table {
      width: 100%;
      margin-top: 20px;
      border-collapse: collapse;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    th, td {
      border: 1px solid #333; /* Darker border */
      padding: 12px 15px;
      text-align: left;
      vertical-align: middle;
    }
    th {
      background: #2c2c2c; /* Header background */
      color: #bb86fc; /* Header text color */
      font-weight: 600;
      font-size: 0.9em;
      text-transform: uppercase;
    }
    td button.close-trade-btn { /* Specific class for close button */
      background: #cf6679; /* Error/danger color */
      color: white;
      padding: 8px 12px;
      font-size: 13px;
    }
    td button.close-trade-btn:hover {
      background: #b00020; /* Darker danger color */
    }
    .tab-bar {
      margin-bottom: 20px;
      border-bottom: 1px solid #333;
      display: flex;
      flex-wrap: wrap; /* Allow tabs to wrap on smaller screens */
    }
    .tab-button {
      padding: 12px 20px;
      margin: 0 2px -1px 0; /* Align with bottom border */
      cursor: pointer;
      border: 1px solid transparent;
      border-bottom: none;
      background: #2c2c2c;
      color: #a0a0a0;
      border-radius: 5px 5px 0 0;
      transition: background-color 0.2s, color 0.2s;
      font-weight: 500;
      white-space: nowrap; /* Prevent text wrapping inside button */
    }
    .tab-button.active {
      background: #1e1e1e; /* Match container background */
      color: #03dac6; /* Active tab text color */
      border-color: #333;
      border-bottom-color: #1e1e1e; /* Hide bottom border part */
      font-weight: bold;
    }
    .tab-content {
      display: none;
      padding: 20px;
      border: 1px solid #333;
      border-top: none;
      border-radius: 0 0 5px 5px;
      background: #252525; /* Slightly different background for content area */
    }
    .tab-content.active {
      display: block;
      animation: fadeIn 0.4s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .message-area { /* For general messages like login status */
      padding: 12px;
      margin-top: 15px;
      border-radius: 5px;
      text-align: center;
      font-size: 0.95em;
    }
    .error-msg { color: #cf6679; background-color: rgba(207, 102, 121, 0.15); border: 1px solid #cf6679; }
    .success-msg { color: #66bb6a; background-color: rgba(102, 187, 106, 0.15); border: 1px solid #66bb6a;}
    .info-msg { color: #29b6f6; background-color: rgba(41, 182, 246, 0.1); border: 1px solid #29b6f6; }


    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.85); /* Darker overlay */
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(4px);
      padding: 15px;
    }
    .modal-content {
      background: #2c2c2c; /* Modal background */
      padding: 25px 30px;
      border-radius: 8px;
      text-align: center;
      width: 100%;
      max-width: 420px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.6);
      animation: modalOpen 0.3s ease-out;
    }
    @keyframes modalOpen {
        from { opacity: 0; transform: scale(0.95) translateY(10px); }
        to { opacity: 1; transform: scale(1) translateY(0); }
    }
    .modal-content p {
        margin-bottom: 20px;
        font-size: 1.1em;
        line-height: 1.5;
        color: #e0e0e0;
    }
    .modal-content button {
      margin: 10px 8px;
      padding: 10px 20px;
    }
    button.confirm-yes { background-color: #cf6679; color: white;}
    button.confirm-yes:hover { background-color: #b00020; }
    button.confirm-no { background-color: #555; color: white;}
    button.confirm-no:hover { background-color: #444; }

    .modal-message {
      margin-top: 15px;
      padding: 10px 15px;
      border-radius: 4px;
      font-weight: bold;
      font-size: 0.95em;
    }
    .modal-message.success { color: #66bb6a; background-color: rgba(102, 187, 106, 0.2); }
    .modal-message.error { color: #cf6679; background-color: rgba(207, 102, 121, 0.2); }
    #modalLoading { color: #a0a0a0; font-style: italic; }

    .history-navigation {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding: 10px;
        background-color: #282828;
        border-radius: 6px;
    }
    .history-navigation button {
        padding: 8px 15px;
        font-size: 14px;
    }
    #historyDateRangeDisplay, #signalsHistoryDateRangeDisplay { /* Combined */
        font-weight: bold;
        color: #c0c0c0;
    }
    .no-data-message {
        text-align: center; 
        padding: 20px; 
        color: #a0a0a0;
    }
    
    #totalOpenPnlDisplay, #historyTabTotalPnlTitleDisplay, #signalsTotalOpenPnlDisplay, #signalsHistoryTabTotalPnlTitleDisplay { /* Combined styles */
        font-size: 0.8em;
        font-weight: normal;
        margin-left: 15px;
        padding: 4px 8px;
        border-radius: 4px;
        color: white; /* Default, will be overridden by JS */
    }
    
    .pnl-positive {
        background-color: rgba(102, 187, 106, 0.2); /* Light green background */
        color: #66bb6a !important; /* Green text, !important to override default if needed */
    }
    
    .pnl-negative {
        background-color: rgba(207, 102, 121, 0.2); /* Light red background */
        color: #cf6679 !important; /* Red text, !important to override default if needed */
    }
    .pnl-neutral {
        background-color: rgba(128, 128, 128, 0.2); /* Light gray background */
        color: #a0a0a0 !important; /* Gray text, !important to override default if needed */
    }


    /* Responsive Table Styles */
    @media screen and (max-width: 768px) {
      #openTradesTab table, #historyTab table, #signalsTab table { /* Apply to all tables */
        border: 0;
        box-shadow: none;
      }

      #openTradesTab thead, #historyTab thead, #signalsTab thead { /* Apply to all tables */
        display: none; /* Hide the original table header */
      }

      #openTradesTab tr, #historyTab tr, #signalsTab tr { /* Apply to all tables */
        display: block;
        margin-bottom: 1.2em; /* Space between cards */
        border: 1px solid #383838; /* Border for each card */
        border-radius: 6px;
        background-color: #282828; /* Card background */
        padding: 0.8em 0.5em; /* Padding inside the card */
      }
      
      #openTradesTab td, #historyTab td, #signalsTab td { /* Apply to all tables */
        display: block;
        text-align: right; /* Align value to the right */
        font-size: 0.9em;
        padding: 10px 12px; /* Padding within each "field" */
        border-bottom: 1px dotted #333; /* Separator for fields */
        position: relative; /* For pseudo-element positioning */
        min-height: 1.5em; /* Ensure space for label */
      }

      #openTradesTab td:last-child, #historyTab td:last-child, #signalsOpenTradesTable td:nth-last-child(2), #signalsHistoryTable td:last-child { 
        /* Last child for history, second to last for signals open (no action button) */
        border-bottom: 0;
      }


      #openTradesTab td::before, #historyTab td::before, #signalsTab td::before { /* Apply to all tables */
        content: attr(data-label); /* Get label from data-label attribute */
        position: absolute;
        left: 12px; /* Position label to the left */
        top: 50%;
        transform: translateY(-50%);
        width: auto; /* Let it take necessary width */
        padding-right: 15px;
        white-space: nowrap;
        text-align: left;
        font-weight: 600; /* Bolder label */
        color: #b0b0b0; /* Label color */
      }

      /* Specific styling for the action button container in Open Trades */
      #openTradesTab td:has(button.close-trade-btn) {
        text-align: center; /* Center the button */
        padding-top: 15px;
        padding-bottom: 10px;
      }
      #openTradesTab td:has(button.close-trade-btn)::before {
        display: none; /* No label for the button cell */
      }

      #openTradesTab td button.close-trade-btn {
        width: auto; 
        min-width: 100px;
        padding: 10px 18px;
        margin: 5px 0;
        font-size: 14px;
      }

      /* Adjust Profit/Loss color and font directly if ::before interferes */
      #openTradesTab td[data-label="Profit/Loss"], 
      #historyTab td[data-label="PNL ($)"],
      #signalsOpenTradesTable td[data-label="Profit/Loss"],
      #signalsHistoryTable td[data-label="PNL ($)"] {
        font-weight: bold; /* Ensure value is bold */
      }
    }
  </style>
<script type="importmap">
{
  "imports": {
    "@google/genai": "https://esm.sh/@google/genai@^1.6.0"
  }
}
</script>
<style>
    /* Nav Sttylles */
    .bottom-nav {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  display: flex;
  justify-content: space-around;
  align-items: center;
  background-color: #1f2937; /* dark background */
  padding: 10px 0;
  box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.6);
  border-top-left-radius: 15px;
  border-top-right-radius: 15px;
  z-index: 1000;
}

.bottom-nav a {
  flex: 1;
  text-align: center;
  padding: 8px 0;
  color: #cccccc;
  font-weight: 500;
  text-decoration: none;
  transition: all 0.3s ease;
  border-radius: 8px;
  margin: 0 5px;
}

.bottom-nav a:hover {
  background-color: #374151;
  color: #a78bfa;
}

.bottom-nav a.active {
  background-color: #4f46e5;
  color: white;
  box-shadow: 0 2px 8px rgba(79, 70, 229, 0.5);
}

</style>

<script>
    document.addEventListener("DOMContentLoaded",()=>{
        const path = window.location.pathname;
        const fileName = path.substring(path.lastIndexOf('/') + 1);
        const activeNavId = {
          'index.html': 'homeNav',
          'betpawa.html': 'betpawaNav',
          'aviator.html': 'aviatorNav',
          'forex.html': 'forexNav',
          '': 'homeNav'
        }[fileName];
      
        if (activeNavId) {
          const link = document.getElementById(activeNavId);
          if (link) link.classList.add('active');
        }

    })
</script>


<script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
  <div class="container">
    <!-- <div class="main-header-container">
      <h2>📊 Deriv Live Trades Dashboard</h2>
      <button id="createDerivAccountBtn" class="secondary-action-button">🚀 Create Deriv Account</button>
    </div> -->
    <div class="main-header-container">
    <div>
        <h1 style="margin: 0; color: #ffffff;">VFBPredictor</h1>
        <h2 style="margin: 0;">📊 Deriv Live Trades Dashboard</h2>
    </div>
    <button id="createDerivAccountBtn" class="secondary-action-button">🚀 Create Deriv Account</button>
    </div>

    <label for="token">🔑 Deriv API Token:</label>
    <input type="text" id="token" size="60" placeholder="Paste your Deriv API token here..." aria-label="Deriv API Token" />
    <button id="connectBtn">🔗 Connect</button>
    <div id="info" class="message-area" role="status" aria-live="assertive"></div>

    <div class="tab-bar">
      <button class="tab-button active" onclick="window.switchTab(event, 'signalsTab')" aria-controls="signalsTab" role="tab">📢 Signals</button>
      <button class="tab-button" onclick="window.switchTab(event, 'tradeTab')" aria-controls="tradeTab" role="tab">📈 Place Trade</button>
      <button class="tab-button" onclick="window.switchTab(event, 'openTradesTab')" aria-controls="openTradesTab" role="tab">📂 Open Positions</button>
      <button class="tab-button" onclick="window.switchTab(event, 'historyTab')" aria-controls="historyTab" role="tab">📜 History</button>
    </div>

    <div id="signalsTab" class="tab-content active" role="tabpanel">
      <h3>📢 Trading Signals Account</h3>
      <div id="signalsInfoDiv" class="message-area info-msg" role="status" aria-live="assertive">Connecting to signals provider...</div>
      
      <h4>Live Open Signals <span id="signalsTotalOpenPnlDisplay" role="status" aria-live="polite"></span></h4>
      <table id="signalsOpenTradesTable" aria-label="Open Signal Trades Table">
        <thead>
          <tr>
            <th>Market</th>
            <th>Buy Price</th>
            <th>Current Value</th>
            <th>Profit/Loss</th>
            <th>Multiplier</th>
            <th>Direction</th>
            <th>Start Time</th>
          </tr>
        </thead>
        <tbody id="signalsOpenTradesTableBody" aria-live="polite"></tbody>
      </table>
      <div id="noSignalsOpenTradesMessage" class="no-data-message" style="display:none;">No open signals at the moment.</div>

      <h4 style="margin-top: 30px;">Signals Account - Weekly PNL <span id="signalsHistoryTabTotalPnlTitleDisplay" role="status" aria-live="polite"></span></h4>
      <div class="history-navigation" id="signalsHistoryNavigation">
          <button id="signalsHistoryPrevWeekBtn" aria-label="Previous Week Signals History">⬅️ Previous Week</button>
          <div id="signalsHistoryDateRangeDisplay" aria-live="polite">Loading date range...</div>
          <button id="signalsHistoryNextWeekBtn" aria-label="Next Week Signals History">Next Week ➡️</button>
      </div>
      <table id="signalsHistoryTable" aria-label="Signals Account Closed Trades History">
          <thead>
              <tr>
                  <th>Market</th>
                  <th>Close Time</th>
                  <th>Direction</th>
                  <th>Stake ($)</th>
                  <th>Value at Close ($)</th>
                  <th>PNL ($)</th>
              </tr>
          </thead>
          <tbody id="signalsHistoryTableBody" aria-live="polite"></tbody>
      </table>
      <div id="noSignalsHistoryTradesMessage" class="no-data-message" style="display:none;">No closed signal trades in this period.</div>
    </div>

    <div id="tradeTab" class="tab-content" role="tabpanel">
      <div class="trade-form">
        <h3>🚀 Open New Multiplier Trade</h3>
        <label for="symbol">Market Symbol:</label>
        <select id="symbol" aria-label="Market Symbol">
          <option value="frxXAUUSD">Gold (XAUUSD)</option>
        </select>
        <label for="stake">Stake Amount ($):</label>
        <input type="number" id="stake" placeholder="e.g. 5" min="0.35" step="any" aria-label="Stake Amount" />
        <label for="multiplier">Multiplier:</label>
        <select id="multiplier" aria-label="Multiplier"></select>
        <label for="direction">Direction:</label>
        <select id="direction" aria-label="Trade Direction">
          <option value="MULTUP">📈 Up (Buy)</option>
          <option value="MULTDOWN">🔻 Down (Sell)</option>
        </select>
        <button onclick="window.placeTrade()">🛒 Place Trade</button>
        <div id="tradeResponse" class="message-area" role="status" aria-live="polite"></div>
      </div>
    </div>

    <div id="openTradesTab" class="tab-content" role="tabpanel">
      <h3>📂 Open Positions <span id="totalOpenPnlDisplay" role="status" aria-live="polite"></span></h3>
      <table id="trades" aria-label="Open Positions Table">
        <thead>
          <tr>
            <th>Market</th>
            <th>Buy Price</th>
            <th>Current Value</th>
            <th>Profit/Loss</th>
            <th>Multiplier</th>
            <th>Direction</th>
            <th>Start Time</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody id="tradeRows" aria-live="polite"></tbody>
      </table>
      <div id="noTradesMessage" class="no-data-message" style="display:none;">No open positions. Use the 'Place Trade' tab to open a new position.</div>
    </div>

    <div id="historyTab" class="tab-content" role="tabpanel">
        <h3>📜 Closed Trades History <span id="historyTabTotalPnlTitleDisplay" role="status" aria-live="polite"></span></h3>
        <div class="history-navigation">
            <button id="historyPrevWeekBtn" aria-label="Previous Week">⬅️ Previous Week</button>
            <div id="historyDateRangeDisplay" aria-live="polite">Loading date range...</div>
            <button id="historyNextWeekBtn" aria-label="Next Week">Next Week ➡️</button>
        </div>
        <table id="historyTable" aria-label="Closed Trades History Table">
            <thead>
                <tr>
                    <th>Market</th>
                    <th>Close Time</th>
                    <th>Direction</th>
                    <th>Stake ($)</th>
                    <th>Value at Close ($)</th>
                    <th>PNL ($)</th>
                </tr>
            </thead>
            <tbody id="historyTableBody" aria-live="polite"></tbody>
        </table>
        <div id="noHistoryTradesMessage" class="no-data-message" style="display:none;">No closed trades in this period.</div>
    </div>

  </div>

  <div class="modal" id="confirmModal" role="dialog" aria-labelledby="modalText" aria-modal="true">
    <div class="modal-content">
      <p id="modalText"></p>
      <div id="modalButtons">
        <button onclick="window.confirmClose(true)" class="confirm-yes">✅ Yes, Close</button>
        <button onclick="window.confirmClose(false)" class="confirm-no">❌ Cancel</button>
      </div>
      <div id="modalLoading" style="display:none;">⏳ Closing trade...</div>
      <div id="modalMessage" class="modal-message" role="alert"></div>
    </div>
  </div>

  <!-- Bottom Navigation -->
<div class="bottom-nav">
  <a href="./index.html" id="homeNav">Home</a>
  <a href="./betpawa.html" id="betpawaNav">Betpawa</a>
  <a href="./aviator.html" id="aviatorNav">Aviator</a>
  <a href="./forex.html" id="forexNav">Forex</a>
</div>


  <script type="module">
const WS_READY_STATE = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3,
};

let ws; // User's WebSocket
let currentToken = '';
let selectedContractId = null;
let openContractsCache = []; 
let closedTradesHistory = [];
let currentHistoryWeekOffset = 0;
const PROFIT_TABLE_PAGE_SIZE = 100;

// Signals Account related variables
const SIGNALS_API_KEY = 'HPtCXXojmjH3Y0r';
let signalsWs; // Signals WebSocket
let signalsOpenContractsCache = [];
let signalsClosedTradesHistory = [];
let currentSignalsHistoryWeekOffset = 0;
let signalsWsConnecting = false;


const symbolNames = {
  'frxXAUUSD': 'Gold (XAUUSD)', 'XAUUSD': 'Gold (XAUUSD)',
  'frxEURUSD': 'EUR/USD', 'EURUSD': 'EUR/USD',
  'frxGBPUSD': 'GBP/USD', 'GBPUSD': 'GBP/USD',
  'frxUSDJPY': 'USD/JPY', 'USDJPY': 'USD/JPY',
  'R_100': 'Volatility 100 Index',
  'R_50': 'Volatility 50 Index',
  'R_25': 'Volatility 25 Index',
  '1HZ100V': 'Volatility 100 1s Index',
  '1HZ50V': 'Volatility 50 1s Index',
  '1HZ25V': 'Volatility 25 1s Index',
  'stpRNG10': 'Step Index 10',
  'stpRNG20': 'Step Index 20',
};

const ui = {
    tokenInput: document.getElementById('token'),
    connectBtn: document.getElementById('connectBtn'),
    createDerivAccountBtn: document.getElementById('createDerivAccountBtn'), // New button
    infoDiv: document.getElementById('info'),
    tradeRows: document.getElementById('tradeRows'),
    tradeResponse: document.getElementById('tradeResponse'),
    symbolSelect: document.getElementById('symbol'),
    stakeInput: document.getElementById('stake'),
    multiplierSelect: document.getElementById('multiplier'),
    directionSelect: document.getElementById('direction'),
    confirmModal: document.getElementById('confirmModal'),
    modalText: document.getElementById('modalText'),
    modalButtons: document.getElementById('modalButtons'),
    modalLoading: document.getElementById('modalLoading'),
    modalMessage: document.getElementById('modalMessage'),
    noTradesMessage: document.getElementById('noTradesMessage'),
    totalOpenPnlDisplay: document.getElementById('totalOpenPnlDisplay'),
    // History Tab UI
    historyTabContent: document.getElementById('historyTab'),
    historyTableBody: document.getElementById('historyTableBody'),
    historyTabTotalPnlTitleDisplay: document.getElementById('historyTabTotalPnlTitleDisplay'),
    historyDateRangeDisplay: document.getElementById('historyDateRangeDisplay'),
    historyPrevWeekBtn: document.getElementById('historyPrevWeekBtn'),
    historyNextWeekBtn: document.getElementById('historyNextWeekBtn'),
    noHistoryTradesMessage: document.getElementById('noHistoryTradesMessage'),
    // Signals Tab UI
    signalsTabContent: document.getElementById('signalsTab'),
    signalsInfoDiv: document.getElementById('signalsInfoDiv'),
    signalsOpenTradesTableBody: document.getElementById('signalsOpenTradesTableBody'),
    signalsTotalOpenPnlDisplay: document.getElementById('signalsTotalOpenPnlDisplay'),
    noSignalsOpenTradesMessage: document.getElementById('noSignalsOpenTradesMessage'),
    signalsHistoryTableBody: document.getElementById('signalsHistoryTableBody'),
    signalsHistoryTabTotalPnlTitleDisplay: document.getElementById('signalsHistoryTabTotalPnlTitleDisplay'),
    signalsHistoryDateRangeDisplay: document.getElementById('signalsHistoryDateRangeDisplay'),
    signalsHistoryPrevWeekBtn: document.getElementById('signalsHistoryPrevWeekBtn'),
    signalsHistoryNextWeekBtn: document.getElementById('signalsHistoryNextWeekBtn'),
    noSignalsHistoryTradesMessage: document.getElementById('noSignalsHistoryTradesMessage'),
};

function getActualApiSymbol(selectedSymbol) {
    if (!selectedSymbol) return selectedSymbol;
    const upperSymbolNoPrefix = selectedSymbol.replace(/^FRX/i, '').toUpperCase();
    const potentialFrxSymbol = "frx" + upperSymbolNoPrefix; 
    if (symbolNames.hasOwnProperty(upperSymbolNoPrefix) && symbolNames.hasOwnProperty(potentialFrxSymbol) && !selectedSymbol.toLowerCase().startsWith("frx")) {
        return potentialFrxSymbol;
    }
    if (symbolNames.hasOwnProperty(selectedSymbol)) {
        return selectedSymbol;
    }
    const commonForexBases = ["XAUUSD", "EURUSD", "GBPUSD", "USDJPY"]; 
    if (commonForexBases.includes(upperSymbolNoPrefix) && !selectedSymbol.toLowerCase().startsWith("frx")) {
        return potentialFrxSymbol; 
    }
    return selectedSymbol;
}

function flashMessage(element, message, type = 'info', duration = 5000) {
    if (!element) return;
    element.innerHTML = message;
    element.className = 'message-area'; // Reset classes first
    if (type === 'info-msg' || type === 'info') element.classList.add('info-msg');
    else if (type === 'success-msg' || type === 'success') element.classList.add('success-msg');
    else if (type === 'error-msg' || type === 'error') element.classList.add('error-msg');
    
    element.style.display = message ? 'block' : 'none';

    if (duration > 0) {
        setTimeout(() => {
            if (element.innerHTML === message) { 
                 element.innerHTML = ''; 
                 element.style.display = 'none';
                 element.className = 'message-area';
            }
        }, duration);
    }
}


function isActiveMultiplier(contract) {
    if (!contract || typeof contract !== 'object' || !contract.contract_id) return false;
    if (contract.is_sold || contract.status === 'sold' || contract.exit_tick_time) return false;
    if (!(contract.contract_type === 'MULTUP' || contract.contract_type === 'MULTDOWN')) return false;
    if (typeof contract.buy_price === 'undefined' || contract.buy_price === null) return false;
    return true;
}

function renderOpenPositionsTable() {
    ui.tradeRows.innerHTML = '';
    let totalOpenPnl = 0;
    const sortedContracts = [...openContractsCache].sort((a, b) => (b.date_start || 0) - (a.date_start || 0));
    
    sortedContracts.forEach(contract => {
        if (isActiveMultiplier(contract)) {
            const row = createTradeRowElement(contract);
            ui.tradeRows.appendChild(row);
            const profit = parseFloat(contract.profit || 0);
            if (!isNaN(profit)) {
                totalOpenPnl += profit;
            }
        }
    });

    if (ui.totalOpenPnlDisplay) {
        ui.totalOpenPnlDisplay.textContent = `Total P/L: $${totalOpenPnl.toFixed(2)}`;
        ui.totalOpenPnlDisplay.className = ''; 
        if (totalOpenPnl > 0) {
            ui.totalOpenPnlDisplay.classList.add('pnl-positive');
        } else if (totalOpenPnl < 0) {
            ui.totalOpenPnlDisplay.classList.add('pnl-negative');
        } else {
            ui.totalOpenPnlDisplay.classList.add('pnl-neutral');
        }
    }
    
    ui.noTradesMessage.style.display = ui.tradeRows.children.length === 0 ? 'block' : 'none';
}

window.switchTab = function(evt, tabId) {
  document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
  document.querySelectorAll('.tab-button').forEach(el => el.classList.remove('active'));
  document.getElementById(tabId).classList.add('active');
  evt.currentTarget.classList.add('active');

  if (tabId === 'openTradesTab') {
    if (ws && ws.readyState === WS_READY_STATE.OPEN) {
      sendToUserWs({ portfolio: 1 });
    }
    renderOpenPositionsTable();
  } else if (tabId === 'historyTab') {
    renderHistoryTab(currentHistoryWeekOffset);
  } else if (tabId === 'signalsTab') {
    if (!signalsWs || (signalsWs.readyState !== WS_READY_STATE.OPEN && signalsWs.readyState !== WS_READY_STATE.CONNECTING)) {
        connectSignalsAccount();
    }
    renderSignalsOpenTradesTable(); // Re-render in case data arrived while tab was inactive
    renderSignalsHistoryTab(currentSignalsHistoryWeekOffset); // Re-render history too
  }
};

function sendToUserWs(data) { // Renamed for clarity
  console.log("fn:sendToUserWs")
  console.log({data})
  if (ws && ws.readyState === WS_READY_STATE.OPEN) {
    console.log("ws.send called")
    ws.send(JSON.stringify(data));
  } else {
    console.warn("User WebSocket not ready or open. Message not sent:", data);
    const isCriticalAction = data.buy || data.sell;
    const isAuthorizeAction = data.authorize;
    const isContractsForAction = data.contracts_for;

    if (isCriticalAction) {
        const feedbackElem = data.sell ? ui.modalMessage : ui.tradeResponse;
        const message = '❌ Connection issue. Please reconnect and try again.';
        if (data.sell) {
            showModalMessage(message, 'error');
        } else {
            flashMessage(feedbackElem, message, 'error-msg', 0);
        }
    } else if (isContractsForAction) {
        setMultiplierSelectState("Connect to API first", true);
    } else if (!isAuthorizeAction && !(ws && ws.readyState === WS_READY_STATE.CONNECTING)) {
        flashMessage(ui.infoDiv, '⚠️ Action could not be sent. Please check connection.', 'error-msg', 5000);
    }

    if (!ws || ws.readyState === WS_READY_STATE.CLOSED || ws.readyState === WS_READY_STATE.CLOSING) {
        flashMessage(ui.infoDiv, '🔌 Connection lost. Please reconnect.', 'error-msg', 0);
        ui.connectBtn.innerText = "🔗 Reconnect";
        ui.connectBtn.disabled = false;
        if (!isContractsForAction) setMultiplierSelectState("Connect to API first", true);
    } else if (ws && ws.readyState === WS_READY_STATE.CONNECTING) {
        if (!isAuthorizeAction && !isContractsForAction) {
            flashMessage(ui.infoDiv, '⏳ Connection in progress. Please wait...', 'info-msg', 5000);
        }
    }
  }
}

function sendToSignalsWs(data) {
    if (signalsWs && signalsWs.readyState === WS_READY_STATE.OPEN) {
        signalsWs.send(JSON.stringify(data));
    } else {
        console.warn("Signals WebSocket not ready or open. Message not sent:", data);
        flashMessage(ui.signalsInfoDiv, '⚠️ Signals provider connection issue. Cannot send request.', 'error-msg', 5000);
    }
}


function fetchInitialClosedTrades() {
    if (!ws || ws.readyState !== WS_READY_STATE.OPEN) {
        console.warn("Cannot fetch closed trades, WebSocket not open.");
        return;
    }
    sendToUserWs({
        profit_table: 1,
        description: 1,
        limit: PROFIT_TABLE_PAGE_SIZE, 
        sort: 'DESC' 
    });
}

window.connect = function() {
  currentToken = ui.tokenInput.value.trim();
  if (!currentToken) {
    alert("Please enter your Deriv API token.");
    return;
  }
  localStorage.setItem("deriv_token", currentToken);
  ui.connectBtn.innerText = "🔄 Connecting...";
  ui.connectBtn.disabled = true;
  flashMessage(ui.infoDiv, "Attempting to connect...", 'info-msg', 0);
  setMultiplierSelectState("Connecting...", true);

  if (ws) {
    ws.onopen = null;
    ws.onmessage = null;
    ws.onclose = null;
    ws.onerror = null;
    if (ws.readyState === WS_READY_STATE.OPEN || ws.readyState === WS_READY_STATE.CONNECTING) {
      ws.close();
    }
  }

  ws = new WebSocket("wss://ws.derivws.com/websockets/v3?app_id=1089");

  ws.onopen = function() {
    const wsInstance = this;
    if (typeof WebSocket === 'undefined') {
        flashMessage(ui.infoDiv, '❌ Internal Error: WebSocket API not available. Auth failed.', 'error-msg', 0);
        ui.connectBtn.innerText = "🔗 Connect";
        ui.connectBtn.disabled = false;
        setMultiplierSelectState("Connection failed", true);
        if (wsInstance && typeof wsInstance.close === 'function' &&
            (wsInstance.readyState === WS_READY_STATE.CONNECTING || wsInstance.readyState === WS_READY_STATE.OPEN)) {
           wsInstance.close();
        }
        return;
    }
    flashMessage(ui.infoDiv, "Authenticating...", 'info-msg', 0);
    if (wsInstance.readyState === WS_READY_STATE.OPEN) {
        try {
            wsInstance.send(JSON.stringify({ authorize: currentToken }));
        } catch (e) {
            flashMessage(ui.infoDiv, `❌ Error during authentication: ${e.message}`, 'error-msg', 0);
            ui.connectBtn.innerText = "🔗 Connect";
            ui.connectBtn.disabled = false;
            setMultiplierSelectState("Auth error", true);
            if (wsInstance && (wsInstance.readyState === WS_READY_STATE.OPEN || wsInstance.readyState === WS_READY_STATE.CONNECTING)) {
                wsInstance.close();
            }
        }
    } else {
        flashMessage(ui.infoDiv, `❌ Connection error: Instance state mismatch on open (${wsInstance.readyState} vs ${WS_READY_STATE.OPEN}). Please try again.`, 'error-msg', 0);
        ui.connectBtn.innerText = "🔗 Connect";
        ui.connectBtn.disabled = false;
        setMultiplierSelectState("Connection error", true);
        if (wsInstance && (wsInstance.readyState === WS_READY_STATE.CONNECTING || wsInstance.readyState === WS_READY_STATE.OPEN)) {
             wsInstance.close();
        }
    }
  };

  ws.onmessage = function(msg) { 
    const data = JSON.parse(msg.data);
    // console.log("[ws.onmessage]")
    // console.log({data})
    if (data.error) {
      let errorStringToLog = data.error.message || JSON.stringify(data.error);
      console.error("User WS Received API Error. Raw error object:", data.error);
      console.error("User WS Received API Error. Details:", errorStringToLog);
      let friendlyErrorMessage = `❌ Error: ${data.error.message || errorStringToLog}`;
      if (data.echo_req && data.echo_req.passthrough && data.echo_req.passthrough.req_type === "multipliers_for_symbol") {
        setMultiplierSelectState("Error loading multipliers", true);
      } else if (data.msg_type === 'buy' || (data.echo_req && data.echo_req.buy)) {
        flashMessage(ui.tradeResponse, friendlyErrorMessage, 'error-msg', 0);
      } else if ((data.msg_type === 'sell' || (data.echo_req && data.echo_req.sell)) && ui.confirmModal.style.display === 'flex') {
        showModalMessage(friendlyErrorMessage, 'error');
      } else {
         flashMessage(ui.infoDiv, friendlyErrorMessage, 'error-msg', 0);
      }
      if (data.msg_type === 'authorize' || (data.echo_req && data.echo_req.authorize)) {
         ui.connectBtn.innerText = "🔗 Connect";
         ui.connectBtn.disabled = false;
         setMultiplierSelectState("Auth failed", true);
      } else if (ws && ws.readyState !== WS_READY_STATE.OPEN) {
         ui.connectBtn.innerText = "🔗 Connect";
         ui.connectBtn.disabled = false;
      }
      return;
    }

    switch(data.msg_type) {
        case "authorize":
            if (data.authorize) {
                flashMessage(ui.infoDiv, `✅ Logged in as: ${data.authorize.loginid}`, 'success-msg', 5000);
                ui.connectBtn.innerText = "🔗 Reconnect";
                openContractsCache = [];
                closedTradesHistory = []; 
                currentHistoryWeekOffset = 0; 
                renderOpenPositionsTable();
                fetchInitialClosedTrades(); 
                sendToUserWs({ portfolio: 1 });
                sendToUserWs({ proposal_open_contract: 1, subscribe: 1 });
                fetchAndPopulateMultipliers(ui.symbolSelect.value); 
            } else {
                flashMessage(ui.infoDiv, `❌ Authorization failed. Check token.`, 'error-msg', 0);
                ui.connectBtn.innerText = "🔗 Connect";
                setMultiplierSelectState("Auth failed", true);
            }
            ui.connectBtn.disabled = false;
            break;

        case "contracts_for":
            if (data.echo_req && data.echo_req.passthrough && data.echo_req.passthrough.req_type === "multipliers_for_symbol") {
                populateMultiplierDropdown(data.contracts_for, data.echo_req.passthrough.symbol);
            }
            break;

        case "portfolio":
            const portfolioContracts = data.portfolio.contracts || [];
            portfolioContracts.forEach(pContract => {
                if (pContract.contract_type === 'MULTUP' || pContract.contract_type === 'MULTDOWN') {
                    const existingIndex = openContractsCache.findIndex(cached => cached.contract_id === pContract.contract_id);
                    if (existingIndex === -1 || typeof openContractsCache[existingIndex].buy_price === 'undefined') {
                         sendToUserWs({ proposal_open_contract: 1, contract_id: pContract.contract_id });
                    }
                }
            });
            if (openContractsCache.length === 0 && portfolioContracts.length === 0) {
                renderOpenPositionsTable();
            }
            break;

        case "proposal_open_contract":
            const c = data.proposal_open_contract;
            if (!c || !c.contract_id) {
              // console.log("!c || !c.contract_id")
            };
            const existingIndexPOC = openContractsCache.findIndex(cached => cached.contract_id === c.contract_id);

            if (isActiveMultiplier(c)) {
                if (existingIndexPOC !== -1) {
                    openContractsCache[existingIndexPOC] = { ...openContractsCache[existingIndexPOC], ...c };
                } else {
                    openContractsCache.push(c);
                }
            } else {
                if (existingIndexPOC !== -1) {
                    openContractsCache.splice(existingIndexPOC, 1);
                }
            }
            renderOpenPositionsTable();
            break;

        //////////
        case "buy":
             if (data.buy && data.buy.contract_id) {
                flashMessage(ui.tradeResponse, `✅ Trade placed! ID: ${data.buy.contract_id}. View in 'Open Positions'.`, 'success-msg', 7000);
                ui.stakeInput.value = '';
             } else if (!data.error) {
                flashMessage(ui.tradeResponse, `⚠️ Trade status uncertain. Please check 'Open Positions'.`, 'info-msg', 7000);
             }
            break;
        
        case "sell":
            if (data.sell && data.sell.contract_id) {
                const { contract_id, sold_for, transaction_id } = data.sell;
                const soldContractId = contract_id;
                const soldForPrice = parseFloat(sold_for);
                const currency = 'USD'; // Sell response doesn't specify currency, assume USD as per app context

                let profitLoss = 0;
                const originalContractDetails = openContractsCache.find(c_1 => c_1.contract_id === soldContractId);

                // Update caches and history
                if (originalContractDetails) {
                    const buyPrice = parseFloat(originalContractDetails.buy_price);
                    if (!isNaN(soldForPrice) && !isNaN(buyPrice)) {
                        profitLoss = soldForPrice - buyPrice;
                    }

                    const marketName = symbolNames[originalContractDetails.underlying] || originalContractDetails.underlying;
                    const direction = ['CALL', 'MULTUP'].includes(originalContractDetails.contract_type) ? '📈 Up' : '🔻 Down';
                    
                    const newHistoryEntry = {
                        contract_id: soldContractId,
                        transaction_id: transaction_id,
                        marketName: marketName,
                        closeTime: Math.floor(Date.now() / 1000), // Use current time as sell response lacks a timestamp
                        direction: direction,
                        stake: buyPrice,
                        valueAtClose: soldForPrice,
                        pnl: profitLoss,
                        currency: currency
                    };

                    if (!closedTradesHistory.some(h => h.transaction_id === newHistoryEntry.transaction_id)) {
                        closedTradesHistory.unshift(newHistoryEntry);
                    }
                }

                const cacheIndex = openContractsCache.findIndex(cached => cached.contract_id === soldContractId);
                if (cacheIndex !== -1) {
                    openContractsCache.splice(cacheIndex, 1);
                }

                // Update UI
                renderOpenPositionsTable();
                if (document.getElementById('historyTab').classList.contains('active')) {
                    renderHistoryTab(currentHistoryWeekOffset);
                }

                // Show final confirmation in the modal
                showModalMessage(`✅ Trade ${soldContractId} closed. P/L: ${profitLoss.toFixed(2)} ${currency}`, 'success');
                setTimeout(closeModal, 2300);
            }
            break;
        //////////
        case "profit_table":
            if (data.profit_table && Array.isArray(data.profit_table.transactions)) {
                closedTradesHistory = data.profit_table.transactions.map(tx => {
                    const shortcodeParts = tx.shortcode.split('_');
                    const contractTypeStr = shortcodeParts[0]; 
                    const apiSymbol = tx.underlying_symbol || shortcodeParts[1]; 
                    
                    let direction = contractTypeStr;
                    if (contractTypeStr === 'MULTUP') direction = '📈 Up';
                    else if (contractTypeStr === 'MULTDOWN') direction = '🔻 Down';

                    const buyPriceRaw = parseFloat(tx.buy_price);
                    const sellPriceRaw = parseFloat(tx.sell_price);
                    
                    const stake = isNaN(buyPriceRaw) ? 0 : buyPriceRaw;
                    const valueAtClose = isNaN(sellPriceRaw) ? 0 : sellPriceRaw;
                    
                    let calculatedPnl = 0;
                    if (!isNaN(buyPriceRaw) && !isNaN(sellPriceRaw)) {
                        calculatedPnl = valueAtClose - stake;
                    } else if (!isNaN(buyPriceRaw) && isNaN(sellPriceRaw)) { 
                        calculatedPnl = -stake; 
                    } 

                    return {
                        contract_id: tx.contract_id,
                        transaction_id: tx.transaction_id,
                        marketName: symbolNames[apiSymbol] || apiSymbol,
                        closeTime: tx.sell_time, 
                        direction: direction,
                        stake: stake,
                        valueAtClose: valueAtClose,
                        pnl: calculatedPnl,
                        currency: tx.currency
                    };
                }).sort((a,b) => b.closeTime - a.closeTime); 
                
                if (document.getElementById('historyTab').classList.contains('active')) {
                    renderHistoryTab(currentHistoryWeekOffset);
                }
            }
            break;

        case "transaction":
          console.log("[transaction]")
          console.log({data})
            if (data.transaction && data.transaction.action === 'sell') {
                const soldContractId = data.transaction.contract_id;
                const profitLossRaw = parseFloat(data.transaction.amount);
                const profitLoss = isNaN(profitLossRaw) ? 0 : profitLossRaw;
                const currency = data.transaction.currency || 'USD';
                const closeTime = data.transaction.transaction_time;

                const originalContractDetails = openContractsCache.find(c_1 => c_1.contract_id === soldContractId);
                if (originalContractDetails) {
                    const marketName = symbolNames[originalContractDetails.underlying] || originalContractDetails.underlying;
                    const direction = ['CALL', 'MULTUP'].includes(originalContractDetails.contract_type) ? '📈 Up' : '🔻 Down';
                    const stakeRaw = parseFloat(originalContractDetails.buy_price);
                    const stake = isNaN(stakeRaw) ? 0 : stakeRaw;
                    
                    const newHistoryEntry = {
                        contract_id: soldContractId,
                        transaction_id: data.transaction.transaction_id, 
                        marketName: marketName,
                        closeTime: closeTime,
                        direction: direction,
                        stake: stake,
                        valueAtClose: stake + profitLoss,
                        pnl: profitLoss, 
                        currency: currency
                    };
                    if (!closedTradesHistory.some(h => h.transaction_id === newHistoryEntry.transaction_id)) {
                        closedTradesHistory.unshift(newHistoryEntry); 
                    }
                }
                
                const cacheIndex = openContractsCache.findIndex(cached => cached.contract_id === soldContractId);
                if (cacheIndex !== -1) {
                    openContractsCache.splice(cacheIndex, 1);
                }
                renderOpenPositionsTable();
                
                if (document.getElementById('historyTab').classList.contains('active')) {
                    renderHistoryTab(currentHistoryWeekOffset);
                }

                showModalMessage(`✅ Trade ${soldContractId} closed. P/L: ${profitLoss.toFixed(2)} ${currency}`, 'success');
                setTimeout(closeModal, 3000);
            }
            break;
    }
  };

  ws.onclose = function(event) {
    flashMessage(ui.infoDiv, "🔌 Connection closed. Click Reconnect.", 'error-msg', 0);
    ui.connectBtn.innerText = "🔗 Reconnect";
    ui.connectBtn.disabled = false;
    openContractsCache = [];
    renderOpenPositionsTable();
    setMultiplierSelectState("Disconnected", true);
  };

  ws.onerror = function(error) {
    flashMessage(ui.infoDiv, "🕸️ Connection error. Please try again.", 'error-msg', 0);
    ui.connectBtn.innerText = "🔗 Connect";
    ui.connectBtn.disabled = false;
    setMultiplierSelectState("Connection error", true);
    if (ui.confirmModal.style.display === 'flex') {
        showModalMessage('❌ Error during operation. Check console.', 'error');
    }
  };
};

function createTradeRowElement(c) {
  const row = document.createElement("tr");
  row.id = `contract-${c.contract_id}`;
  const symbolKey = c.underlying || c.symbol || (c.shortcode?.split('_')[1]) || 'N/A';
  const marketName = symbolNames[symbolKey] || symbolKey;
  const direction = ['CALL', 'MULTUP'].includes(c.contract_type) ? '📈 Up' : ['PUT', 'MULTDOWN'].includes(c.contract_type) ? '🔻 Down' : c.contract_type || 'N/A';
  const profit = parseFloat(c.profit || 0);
  const bidPrice = parseFloat(c.bid_price || 0);
  const buyPrice = parseFloat(c.buy_price || 0);
  const multiplier = c.multiplier || 'N/A';

  // Robustly escape marketName for HTML attributes and JavaScript string literals
  const safeMarketNameForHtml = marketName.replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  const safeMarketNameForJs = JSON.stringify(marketName);
// console.log(`<td><button class="close-trade-btn" onclick="window.openModal(${c.contract_id}, '${safeMarketNameForHtml}')" aria-label="Close trade for ${safeMarketNameForHtml}">Close</button></td>`)
  row.innerHTML = `
    <td data-label="Market">${marketName}</td>
    <td data-label="Buy Price">$${buyPrice.toFixed(2)}</td>
    <td data-label="Current Value">$${bidPrice.toFixed(2)}</td>
    <td data-label="Profit/Loss" style="color:${profit >= 0 ? '#66bb6a' : '#cf6679'}; font-weight: bold;">$${profit.toFixed(2)}</td>
    <td data-label="Multiplier">${multiplier}x</td>
    <td data-label="Direction">${direction}</td>
    <td data-label="Start Time">${c.date_start ? new Date(c.date_start * 1000).toLocaleString([], { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true }) : '-'}</td>
    <td><button class="close-trade-btn" onclick="window.openModal(${c.contract_id}, '${safeMarketNameForHtml}')" aria-label="Close trade for ${safeMarketNameForHtml}">Close</button></td>
  `;
  return row;
}

window.openModal = function(contractId, marketName = '') {
  console.log("(fn:openModal)")
  selectedContractId = contractId;
  let modalTextContent = `Close trade ${contractId}?`;
  // marketName is already a JS string (potentially from JSON.stringify), so direct usage is fine.
  const actualMarketName = marketName || (openContractsCache.find(c_1 => c_1.contract_id === contractId) ? (symbolNames[openContractsCache.find(c_1 => c_1.contract_id === contractId).underlying || openContractsCache.find(c_1 => c_1.contract_id === contractId).symbol] || openContractsCache.find(c_1 => c_1.contract_id === contractId).underlying || openContractsCache.find(c_1 => c_1.contract_id === contractId).symbol) : '');
  console.log({actualMarketName})
  if (actualMarketName) {
      modalTextContent = `Are you sure you want to close the trade for ${actualMarketName} (ID: ${contractId})?`;
  } else {
      modalTextContent = `Are you sure you want to close the trade with ID: ${contractId}?`;
  }
  ui.modalText.innerText = modalTextContent;
  ui.modalButtons.style.display = 'flex';
  ui.modalLoading.style.display = 'none';
  ui.modalMessage.innerHTML = '';
  ui.modalMessage.className = 'modal-message';
  ui.confirmModal.style.display = 'flex';
};

window.confirmClose = function(confirm) { 
  console.log("(fn:confirmClose)")
  console.log({confirmClose,selectedContractId})
  if (confirm && selectedContractId !== null) {
    ui.modalButtons.style.display = 'none';
    ui.modalLoading.style.display = 'block';
    ui.modalMessage.innerHTML = '';
    console.log("sending: to sendToUserWs")
    sendToUserWs({ sell: selectedContractId, price: 0 }); 


  } else {
    closeModal();
  }
};

function showModalMessage(message, type) {
  ui.modalLoading.style.display = 'none';
  ui.modalMessage.innerHTML = message;
  ui.modalMessage.className = `modal-message ${type}`;
  ui.modalButtons.style.display = (type === 'success') ? 'none' : 'flex';
}

function closeModal() {
  ui.confirmModal.style.display = 'none';
  selectedContractId = null;
  ui.modalText.innerText = '';
  ui.modalMessage.innerHTML = '';
  ui.modalMessage.className = 'modal-message';
  ui.modalButtons.style.display = 'flex';
  ui.modalLoading.style.display = 'none';
}

function setMultiplierSelectState(message, disabled) {
    if (!ui.multiplierSelect) return;
    ui.multiplierSelect.innerHTML = '';
    const placeholderOption = document.createElement('option');
    placeholderOption.value = "";
    placeholderOption.textContent = message;
    placeholderOption.disabled = true;
    placeholderOption.selected = true;
    ui.multiplierSelect.appendChild(placeholderOption);
    ui.multiplierSelect.disabled = disabled;
}

function fetchAndPopulateMultipliers(selectedSymbolValue) {
    const apiSymbol = getActualApiSymbol(selectedSymbolValue);
    if (!apiSymbol) {
        setMultiplierSelectState("Select a market symbol", true);
        return;
    }
    if (!ws || ws.readyState !== WS_READY_STATE.OPEN) {
        setMultiplierSelectState("Connect to API first", true);
        return;
    }
    setMultiplierSelectState("Loading multipliers...", true);
    sendToUserWs({
        contracts_for: apiSymbol,
        currency: "USD",
        product_type: "basic", 
        passthrough: { "req_type": "multipliers_for_symbol", "symbol": apiSymbol }
    });
}

function populateMultiplierDropdown(contractsForData, symbolFromPassthrough) {
    if (!ui.multiplierSelect) return;
    const currentSelectedSymbolValue = ui.symbolSelect.value;
    const currentApiSymbol = getActualApiSymbol(currentSelectedSymbolValue);

    if (symbolFromPassthrough !== currentApiSymbol) {
        if (!ui.multiplierSelect.disabled || (ui.multiplierSelect.firstChild && ui.multiplierSelect.firstChild.textContent !== "Loading multipliers...")) {
             return; 
        }
    }
    
    if (!contractsForData || !Array.isArray(contractsForData.available)) {
        setMultiplierSelectState("Error: Multiplier data format", true);
        return;
    }
    let allParsedMultipliers = [];
    contractsForData.available.forEach(contractDetail => {
        if (contractDetail && Array.isArray(contractDetail.multiplier_range) && contractDetail.multiplier_range.length > 0) {
            const numericMultipliers = contractDetail.multiplier_range
                .map(m_val => parseFloat(m_val))
                .filter(m_num => !isNaN(m_num) && m_num > 0); 
            if(numericMultipliers.length > 0) {
                allParsedMultipliers.push(...numericMultipliers);
            }
        }
    });
    
    let availableMultipliers = [];
    if (allParsedMultipliers.length > 0) {
        availableMultipliers = [...new Set(allParsedMultipliers)].sort((a, b) => a - b);
    }
    ui.multiplierSelect.innerHTML = ''; 
    if (availableMultipliers.length > 0) {
        availableMultipliers.forEach(m => {
            const option = document.createElement('option');
            option.value = m;
            option.textContent = `${m}x`;
            ui.multiplierSelect.appendChild(option);
        });
        ui.multiplierSelect.disabled = false;
    } else {
        setMultiplierSelectState("No multipliers available", true);
    }
}

window.placeTrade = function() {
  const selectedSymbolValue = ui.symbolSelect.value;
  const apiSymbol = getActualApiSymbol(selectedSymbolValue);
  const stake = ui.stakeInput.value;
  const multiplier = ui.multiplierSelect.value; 
  const direction = ui.directionSelect.value;
  flashMessage(ui.tradeResponse, '', 'info-msg', 0); 
  if (!apiSymbol || !stake || !multiplier || multiplier === "" || !direction) { 
    flashMessage(ui.tradeResponse, '❌ Please fill all fields and select a valid multiplier.', 'error-msg', 5000);
    return;
  }
  const stakeAmount = parseFloat(stake);
  const multiplierAmount = parseInt(multiplier); 
  if (isNaN(stakeAmount) || isNaN(multiplierAmount) || stakeAmount <= 0 || multiplierAmount <= 0) {
    flashMessage(ui.tradeResponse, '❌ Stake must be a positive number and multiplier must be selected.', 'error-msg', 5000);
    return;
  }
   if (stakeAmount < 0.35) { 
    flashMessage(ui.tradeResponse, '❌ Minimum stake is typically $0.35. Please check current limits.', 'error-msg', 5000);
    return;
  }
  if (!ws || ws.readyState !== WS_READY_STATE.OPEN) {
    flashMessage(ui.tradeResponse, '❌ Not connected to Deriv. Please connect first.', 'error-msg', 5000);
    return;
  }
  const tradeRequest = {
    buy: "1", 
    price: stakeAmount, 
    parameters: {
      amount: stakeAmount,
      basis: "stake",
      contract_type: direction, 
      currency: "USD",
      symbol: apiSymbol, 
      multiplier: multiplierAmount,
    },
    subscribe: 1 
  };
  flashMessage(ui.tradeResponse, '⏳ Sending trade request...', 'info-msg', 0);
  sendToUserWs(tradeRequest);
};

// --- History Tab Functions ---
function getWeekDateRange(offsetWeeks = 0) {
    const now = new Date();
    now.setDate(now.getDate() + offsetWeeks * 7);

    const dayOfWeek = now.getDay(); 
    
    const startDate = new Date(now);
    startDate.setDate(now.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1)); 
    startDate.setHours(0, 0, 0, 0);

    const endDate = new Date(startDate);
    endDate.setDate(startDate.getDate() + 6);
    endDate.setHours(23, 59, 59, 999);

    const options = { month: 'short', day: 'numeric', year: 'numeric' };
    const displayRangeString = `${startDate.toLocaleDateString(undefined, options)} - ${endDate.toLocaleDateString(undefined, options)}`;
    
    return { startDate, endDate, displayRangeString };
}

function renderHistoryTab(weekOffset = 0) {
    if (!ui.historyTabContent || !closedTradesHistory) return;

    const { startDate, endDate, displayRangeString } = getWeekDateRange(weekOffset);
    ui.historyDateRangeDisplay.textContent = displayRangeString;

    const tradesForWeek = closedTradesHistory.filter(trade => {
        const closeDate = new Date(trade.closeTime * 1000);
        return closeDate >= startDate && closeDate <= endDate;
    });

    ui.historyTableBody.innerHTML = '';
    let totalPnlForWeek = 0;

    if (tradesForWeek.length > 0) {
        tradesForWeek.forEach(trade => {
            const row = document.createElement('tr');
            const pnlColor = trade.pnl >= 0 ? '#66bb6a' : '#cf6679';
            const pnlValue = typeof trade.pnl === 'number' ? trade.pnl : 0;
            const stakeValue = typeof trade.stake === 'number' ? trade.stake : 0;
            const valueAtCloseValue = typeof trade.valueAtClose === 'number' ? trade.valueAtClose : 0;

            row.innerHTML = `
                <td data-label="Market">${trade.marketName}</td>
                <td data-label="Close Time">${new Date(trade.closeTime * 1000).toLocaleString([], { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true })}</td>
                <td data-label="Direction">${trade.direction}</td>
                <td data-label="Stake ($)">${stakeValue.toFixed(2)}</td>
                <td data-label="Value at Close ($)">${valueAtCloseValue.toFixed(2)}</td>
                <td data-label="PNL ($)" style="color:${pnlColor}; font-weight: bold;">${pnlValue.toFixed(2)}</td>
            `;
            ui.historyTableBody.appendChild(row);
            totalPnlForWeek += pnlValue;
        });
        ui.noHistoryTradesMessage.style.display = 'none';
    } else {
        ui.noHistoryTradesMessage.style.display = 'block';
    }

    if (ui.historyTabTotalPnlTitleDisplay) {
        ui.historyTabTotalPnlTitleDisplay.textContent = `Total P/L: $${totalPnlForWeek.toFixed(2)}`;
        ui.historyTabTotalPnlTitleDisplay.className = ''; 
        if (totalPnlForWeek > 0) {
            ui.historyTabTotalPnlTitleDisplay.classList.add('pnl-positive');
        } else if (totalPnlForWeek < 0) {
            ui.historyTabTotalPnlTitleDisplay.classList.add('pnl-negative');
        } else {
            ui.historyTabTotalPnlTitleDisplay.classList.add('pnl-neutral');
        }
    }
    
    ui.historyNextWeekBtn.disabled = weekOffset >= 0; 
}


// --- Signals Tab Functions ---
function connectSignalsAccount() {
    if (signalsWsConnecting || (signalsWs && (signalsWs.readyState === WS_READY_STATE.OPEN || signalsWs.readyState === WS_READY_STATE.CONNECTING))) {
        flashMessage(ui.signalsInfoDiv, 'ℹ️ Signals provider connection already active or in progress.', 'info-msg', 3000);
        return;
    }
    signalsWsConnecting = true;
    flashMessage(ui.signalsInfoDiv, '⏳ Connecting to signals provider...', 'info-msg', 0);

    if (signalsWs) {
        signalsWs.onopen = null;
        signalsWs.onmessage = null;
        signalsWs.onclose = null;
        signalsWs.onerror = null;
        if (signalsWs.readyState === WS_READY_STATE.OPEN || signalsWs.readyState === WS_READY_STATE.CONNECTING) {
            signalsWs.close();
        }
    }

    signalsWs = new WebSocket("wss://ws.derivws.com/websockets/v3?app_id=1089");

    signalsWs.onopen = function() {
        signalsWsConnecting = false;
        flashMessage(ui.signalsInfoDiv, 'Authenticating signals provider...', 'info-msg', 0);
        sendToSignalsWs({ authorize: SIGNALS_API_KEY });
    };

    signalsWs.onmessage = function(msg) {
        const data = JSON.parse(msg.data);

        if (data.error) {
            console.error("Signals WS Error:", data.error);
            flashMessage(ui.signalsInfoDiv, `❌ Signals Error: ${data.error.message}`, 'error-msg', 0);
            signalsWsConnecting = false;
            return;
        }

        switch (data.msg_type) {
            case "authorize":
                if (data.authorize) {
                    flashMessage(ui.signalsInfoDiv, `✅ Signals provider connected: ${data.authorize.loginid}`, 'success-msg', 5000);
                    signalsOpenContractsCache = [];
                    signalsClosedTradesHistory = [];
                    currentSignalsHistoryWeekOffset = 0;
                    renderSignalsOpenTradesTable();
                    renderSignalsHistoryTab(currentSignalsHistoryWeekOffset);

                    sendToSignalsWs({ portfolio: 1 });
                    sendToSignalsWs({ profit_table: 1, description: 1, limit: PROFIT_TABLE_PAGE_SIZE, sort: 'DESC' });
                    sendToSignalsWs({ proposal_open_contract: 1, subscribe: 1 });
                } else {
                    flashMessage(ui.signalsInfoDiv, `❌ Signals provider authorization failed.`, 'error-msg', 0);
                    signalsWsConnecting = false;
                }
                break;
            case "portfolio":
                const portfolioContracts = data.portfolio.contracts || [];
                portfolioContracts.forEach(pContract => {
                     if (pContract.contract_type === 'MULTUP' || pContract.contract_type === 'MULTDOWN') {
                        const existingIndex = signalsOpenContractsCache.findIndex(cached => cached.contract_id === pContract.contract_id);
                        if (existingIndex === -1 || typeof signalsOpenContractsCache[existingIndex].buy_price === 'undefined') { // If new or incomplete
                             sendToSignalsWs({ proposal_open_contract: 1, contract_id: pContract.contract_id });
                        }
                    }
                });
                if (signalsOpenContractsCache.length === 0 && portfolioContracts.length === 0) {
                    renderSignalsOpenTradesTable(); // Ensure table is updated if initially empty
                }
                break;
            case "proposal_open_contract":
                const c = data.proposal_open_contract;
                if (!c || !c.contract_id) return;
                const existingIndexPOC = signalsOpenContractsCache.findIndex(cached => cached.contract_id === c.contract_id);
                if (isActiveMultiplier(c)) {
                    if (existingIndexPOC !== -1) {
                        signalsOpenContractsCache[existingIndexPOC] = { ...signalsOpenContractsCache[existingIndexPOC], ...c };
                    } else {
                        signalsOpenContractsCache.push(c);
                    }
                } else { // Contract is no longer active (e.g. sold, expired)
                    if (existingIndexPOC !== -1) {
                        signalsOpenContractsCache.splice(existingIndexPOC, 1);
                    }
                }
                renderSignalsOpenTradesTable();
                break;
            //////
case "buy":
             if (data.buy && data.buy.contract_id) {
                flashMessage(ui.tradeResponse, `✅ Trade placed! ID: ${data.buy.contract_id}. View in 'Open Positions'.`, 'success-msg', 7000);
                ui.stakeInput.value = '';
             } else if (!data.error) {
                flashMessage(ui.tradeResponse, `⚠️ Trade status uncertain. Please check 'Open Positions'.`, 'info-msg', 7000);
             }
            break;
        
        case "sell":
            console.log("sell")
            console.log({data})
            if (data.sell && data.sell.contract_id) {
                const { contract_id, sold_for, transaction_id } = data.sell;
                const soldContractId = contract_id;
                const soldForPrice = parseFloat(sold_for);
                const currency = 'USD'; // Sell response doesn't specify currency, assume USD as per app context

                let profitLoss = 0;
                const originalContractDetails = openContractsCache.find(c_1 => c_1.contract_id === soldContractId);

                // Update caches and history
                if (originalContractDetails) {
                    const buyPrice = parseFloat(originalContractDetails.buy_price);
                    if (!isNaN(soldForPrice) && !isNaN(buyPrice)) {
                        profitLoss = soldForPrice - buyPrice;
                    }

                    const marketName = symbolNames[originalContractDetails.underlying] || originalContractDetails.underlying;
                    const direction = ['CALL', 'MULTUP'].includes(originalContractDetails.contract_type) ? '📈 Up' : '🔻 Down';
                    
                    const newHistoryEntry = {
                        contract_id: soldContractId,
                        transaction_id: transaction_id,
                        marketName: marketName,
                        closeTime: Math.floor(Date.now() / 1000), // Use current time as sell response lacks a timestamp
                        direction: direction,
                        stake: buyPrice,
                        valueAtClose: soldForPrice,
                        pnl: profitLoss,
                        currency: currency
                    };

                    if (!closedTradesHistory.some(h => h.transaction_id === newHistoryEntry.transaction_id)) {
                        closedTradesHistory.unshift(newHistoryEntry);
                    }
                }

                const cacheIndex = openContractsCache.findIndex(cached => cached.contract_id === soldContractId);
                if (cacheIndex !== -1) {
                    openContractsCache.splice(cacheIndex, 1);
                }

                // Update UI
                renderOpenPositionsTable();
                if (document.getElementById('historyTab').classList.contains('active')) {
                    renderHistoryTab(currentHistoryWeekOffset);
                }

                // Show final confirmation in the modal
                showModalMessage(`✅ Trade ${soldContractId} closed. P/L: ${profitLoss.toFixed(2)} ${currency}`, 'success');
                setTimeout(closeModal, 3000);
            }
            break;
            //////
            case "profit_table":
                if (data.profit_table && Array.isArray(data.profit_table.transactions)) {
                    signalsClosedTradesHistory = data.profit_table.transactions.map(tx => {
                        const shortcodeParts = tx.shortcode.split('_');
                        const contractTypeStr = shortcodeParts[0];
                        const apiSymbol = tx.underlying_symbol || shortcodeParts[1];
                        let direction = contractTypeStr;
                        if (contractTypeStr === 'MULTUP') direction = '📈 Up';
                        else if (contractTypeStr === 'MULTDOWN') direction = '🔻 Down';
                        
                        const buyPriceRaw = parseFloat(tx.buy_price);
                        const sellPriceRaw = parseFloat(tx.sell_price);
                        const stake = isNaN(buyPriceRaw) ? 0 : buyPriceRaw;
                        const valueAtClose = isNaN(sellPriceRaw) ? 0 : sellPriceRaw;
                        let calculatedPnl = 0;
                        if (!isNaN(buyPriceRaw) && !isNaN(sellPriceRaw)) {
                            calculatedPnl = valueAtClose - stake;
                        } else if (!isNaN(buyPriceRaw) && isNaN(sellPriceRaw)) {
                            calculatedPnl = -stake;
                        }

                        return {
                            contract_id: tx.contract_id,
                            transaction_id: tx.transaction_id,
                            marketName: symbolNames[apiSymbol] || apiSymbol,
                            closeTime: tx.sell_time,
                            direction: direction,
                            stake: stake,
                            valueAtClose: valueAtClose,
                            pnl: calculatedPnl,
                            currency: tx.currency
                        };
                    }).sort((a,b) => b.closeTime - a.closeTime);
                    
                    if (document.getElementById('signalsTab').classList.contains('active')) {
                         renderSignalsHistoryTab(currentSignalsHistoryWeekOffset);
                    }
                }
                break;
             case "transaction": // Handle if a signal trade gets closed during session
                if (data.transaction && data.transaction.action === 'sell') {
                    const soldContractId = data.transaction.contract_id;
                    const profitLossRaw = parseFloat(data.transaction.amount);
                    const profitLoss = isNaN(profitLossRaw) ? 0 : profitLossRaw;

                    const originalSignalContract = signalsOpenContractsCache.find(c_1 => c_1.contract_id === soldContractId);
                    if (originalSignalContract) {
                         const marketName = symbolNames[originalSignalContract.underlying] || originalSignalContract.underlying;
                         const direction = ['CALL', 'MULTUP'].includes(originalSignalContract.contract_type) ? '📈 Up' : '🔻 Down';
                         const stakeRaw = parseFloat(originalSignalContract.buy_price);
                         const stake = isNaN(stakeRaw) ? 0 : stakeRaw;

                        const newSignalHistoryEntry = {
                            contract_id: soldContractId,
                            transaction_id: data.transaction.transaction_id,
                            marketName: marketName,
                            closeTime: data.transaction.transaction_time,
                            direction: direction,
                            stake: stake,
                            valueAtClose: stake + profitLoss,
                            pnl: profitLoss,
                            currency: data.transaction.currency || 'USD'
                        };
                        if (!signalsClosedTradesHistory.some(h => h.transaction_id === newSignalHistoryEntry.transaction_id)) {
                             signalsClosedTradesHistory.unshift(newSignalHistoryEntry);
                        }
                    }
                    const cacheIndex = signalsOpenContractsCache.findIndex(cached => cached.contract_id === soldContractId);
                    if (cacheIndex !== -1) {
                        signalsOpenContractsCache.splice(cacheIndex, 1);
                    }
                    renderSignalsOpenTradesTable();
                    if (document.getElementById('signalsTab').classList.contains('active')) {
                        renderSignalsHistoryTab(currentSignalsHistoryWeekOffset);
                    }
                }
                break;

        }
    };

    signalsWs.onclose = function() {
        signalsWsConnecting = false;
        flashMessage(ui.signalsInfoDiv, '🔌 Signals provider disconnected.', 'error-msg', 0);
        signalsOpenContractsCache = []; // Clear cache on disconnect
        renderSignalsOpenTradesTable(); // Update UI
    };

    signalsWs.onerror = function(error) {
        signalsWsConnecting = false;
        console.error("Signals WS Error object:", error);
        flashMessage(ui.signalsInfoDiv, '🕸️ Signals provider connection error.', 'error-msg', 0);
    };
}

function renderSignalsOpenTradesTable() {
    ui.signalsOpenTradesTableBody.innerHTML = '';
    let totalOpenPnl = 0;
    const sortedContracts = [...signalsOpenContractsCache].sort((a, b) => (b.date_start || 0) - (a.date_start || 0));

    sortedContracts.forEach(contract => {
        if (isActiveMultiplier(contract)) {
            const row = createSignalTradeRowElement(contract); // Use a specific renderer for signals
            ui.signalsOpenTradesTableBody.appendChild(row);
            const profit = parseFloat(contract.profit || 0);
            if (!isNaN(profit)) {
                totalOpenPnl += profit;
            }
        }
    });

    if (ui.signalsTotalOpenPnlDisplay) {
        ui.signalsTotalOpenPnlDisplay.textContent = `Total P/L: $${totalOpenPnl.toFixed(2)}`;
        ui.signalsTotalOpenPnlDisplay.className = ''; 
        if (totalOpenPnl > 0) {
            ui.signalsTotalOpenPnlDisplay.classList.add('pnl-positive');
        } else if (totalOpenPnl < 0) {
            ui.signalsTotalOpenPnlDisplay.classList.add('pnl-negative');
        } else {
            ui.signalsTotalOpenPnlDisplay.classList.add('pnl-neutral');
        }
    }
    ui.noSignalsOpenTradesMessage.style.display = ui.signalsOpenTradesTableBody.children.length === 0 ? 'block' : 'none';
}

function createSignalTradeRowElement(c) {
  const row = document.createElement("tr");
  const symbolKey = c.underlying || c.symbol || (c.shortcode?.split('_')[1]) || 'N/A';
  const marketName = symbolNames[symbolKey] || symbolKey;
  const direction = ['CALL', 'MULTUP'].includes(c.contract_type) ? '📈 Up' : ['PUT', 'MULTDOWN'].includes(c.contract_type) ? '🔻 Down' : c.contract_type || 'N/A';
  const profit = parseFloat(c.profit || 0);
  const bidPrice = parseFloat(c.bid_price || 0);
  const buyPrice = parseFloat(c.buy_price || 0);
  const multiplier = c.multiplier || 'N/A';

  row.innerHTML = `
    <td data-label="Market">${marketName}</td>
    <td data-label="Buy Price">$${buyPrice.toFixed(2)}</td>
    <td data-label="Current Value">$${bidPrice.toFixed(2)}</td>
    <td data-label="Profit/Loss" style="color:${profit >= 0 ? '#66bb6a' : '#cf6679'}; font-weight: bold;">$${profit.toFixed(2)}</td>
    <td data-label="Multiplier">${multiplier}x</td>
    <td data-label="Direction">${direction}</td>
    <td data-label="Start Time">${c.date_start ? new Date(c.date_start * 1000).toLocaleString([], { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true }) : '-'}</td>
  `;
  return row;
}

function renderSignalsHistoryTab(weekOffset = 0) {
    if (!ui.signalsTabContent || !signalsClosedTradesHistory) return;

    const { startDate, endDate, displayRangeString } = getWeekDateRange(weekOffset);
    ui.signalsHistoryDateRangeDisplay.textContent = displayRangeString;

    const tradesForWeek = signalsClosedTradesHistory.filter(trade => {
        const closeDate = new Date(trade.closeTime * 1000);
        return closeDate >= startDate && closeDate <= endDate;
    });

    ui.signalsHistoryTableBody.innerHTML = '';
    let totalPnlForWeek = 0;

    if (tradesForWeek.length > 0) {
        tradesForWeek.forEach(trade => {
            const row = document.createElement('tr');
            const pnlColor = trade.pnl >= 0 ? '#66bb6a' : '#cf6679';
            const pnlValue = typeof trade.pnl === 'number' ? trade.pnl : 0;
            const stakeValue = typeof trade.stake === 'number' ? trade.stake : 0;
            const valueAtCloseValue = typeof trade.valueAtClose === 'number' ? trade.valueAtClose : 0;

            row.innerHTML = `
                <td data-label="Market">${trade.marketName}</td>
                <td data-label="Close Time">${new Date(trade.closeTime * 1000).toLocaleString([], { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true })}</td>
                <td data-label="Direction">${trade.direction}</td>
                <td data-label="Stake ($)">${stakeValue.toFixed(2)}</td>
                <td data-label="Value at Close ($)">${valueAtCloseValue.toFixed(2)}</td>
                <td data-label="PNL ($)" style="color:${pnlColor}; font-weight: bold;">${pnlValue.toFixed(2)}</td>
            `;
            ui.signalsHistoryTableBody.appendChild(row);
            totalPnlForWeek += pnlValue;
        });
        ui.noSignalsHistoryTradesMessage.style.display = 'none';
    } else {
        ui.noSignalsHistoryTradesMessage.style.display = 'block';
    }

    if (ui.signalsHistoryTabTotalPnlTitleDisplay) {
        ui.signalsHistoryTabTotalPnlTitleDisplay.textContent = `Total P/L: $${totalPnlForWeek.toFixed(2)}`;
        ui.signalsHistoryTabTotalPnlTitleDisplay.className = ''; 
        if (totalPnlForWeek > 0) {
            ui.signalsHistoryTabTotalPnlTitleDisplay.classList.add('pnl-positive');
        } else if (totalPnlForWeek < 0) {
            ui.signalsHistoryTabTotalPnlTitleDisplay.classList.add('pnl-negative');
        } else {
            ui.signalsHistoryTabTotalPnlTitleDisplay.classList.add('pnl-neutral');
        }
    }
    ui.signalsHistoryNextWeekBtn.disabled = weekOffset >= 0;
}


// --- Event Listeners ---
window.addEventListener('load', () => {
  if (ui.connectBtn) {
      ui.connectBtn.addEventListener('click', window.connect);
  }
  if (ui.createDerivAccountBtn) { // Add listener for the new button
      ui.createDerivAccountBtn.addEventListener('click', () => {
          const affiliateLink = 'https://track.deriv.com/_7Nhiq0l96up0QQMXeD9If2Nd7ZgqdRLk/1/';
          if (window.Telegram && window.Telegram.WebApp && typeof window.Telegram.WebApp.openLink === 'function') {
              window.Telegram.WebApp.openLink(affiliateLink, {try_instant_view: false});
          } else {
              window.open(affiliateLink, '_blank');
              console.warn("Telegram.WebApp.openLink not available. Opened link in a new tab as fallback.");
          }
      });
  }

  const savedToken = localStorage.getItem("deriv_token");
  if (savedToken) {
    ui.tokenInput.value = savedToken;
  }

  if (ui.multiplierSelect) { 
      setMultiplierSelectState("Select market & connect", true);
  }
  if (ui.symbolSelect) {
    ui.symbolSelect.addEventListener('change', (event) => {
        fetchAndPopulateMultipliers(event.target.value);
    });
  }

  if (ui.historyPrevWeekBtn) {
    ui.historyPrevWeekBtn.addEventListener('click', () => {
        currentHistoryWeekOffset--;
        renderHistoryTab(currentHistoryWeekOffset);
    });
  }
  if (ui.historyNextWeekBtn) {
    ui.historyNextWeekBtn.addEventListener('click', () => {
        if (currentHistoryWeekOffset < 0) { 
            currentHistoryWeekOffset++;
            renderHistoryTab(currentHistoryWeekOffset); 
        }
    });
  }

  // Signals History Navigation
  if (ui.signalsHistoryPrevWeekBtn) {
    ui.signalsHistoryPrevWeekBtn.addEventListener('click', () => {
        currentSignalsHistoryWeekOffset--;
        renderSignalsHistoryTab(currentSignalsHistoryWeekOffset);
    });
  }
  if (ui.signalsHistoryNextWeekBtn) {
    ui.signalsHistoryNextWeekBtn.addEventListener('click', () => {
        if (currentSignalsHistoryWeekOffset < 0) {
            currentSignalsHistoryWeekOffset++;
            renderSignalsHistoryTab(currentSignalsHistoryWeekOffset);
        }
    });
  }

  renderOpenPositionsTable();
  renderHistoryTab(currentHistoryWeekOffset); 
  renderSignalsOpenTradesTable(); // Initial render for signals open trades
  renderSignalsHistoryTab(currentSignalsHistoryWeekOffset); // Initial render for signals history

  const activeTabButton = document.querySelector('.tab-button.active');
  if (activeTabButton) {
      const tabId = activeTabButton.getAttribute('aria-controls');
      if (tabId) {
          const activeTabContent = document.getElementById(tabId);
          if (activeTabContent) {
              document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
              activeTabContent.classList.add('active');
              if (tabId === 'signalsTab') { // Connect signals if it's the active tab on load
                connectSignalsAccount();
              }
          }
      }
  } else { 
      const firstTabButton = document.querySelector('.tab-button');
      if (firstTabButton) {
          const tabId = firstTabButton.getAttribute('aria-controls');
          const tabContent = document.getElementById(tabId);
          if (tabContent) {
            tabContent.classList.add('active');
            firstTabButton.classList.add('active');
            if (tabId === 'signalsTab') { // Connect signals if it's the default tab
                connectSignalsAccount();
            }
          }
      }
  }
});
  </script>
</body>
</html>
